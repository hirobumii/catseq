# Compiler Implementation Notes

编译器 Pass 逻辑分析

  Pass 0: `_pass0_extract_events` (事件提取)

   * 逻辑: 这是编译的第一步。它将用户构建的、高度抽象的 Morphism
     对象“压平”，转换成一个按板卡（OASMAddress）组织的、按时间排序的 LogicalEvent
     列表。它处理了板卡内多通道（Lane）的合并，并将每个原子操作（AtomicMorphism）转换成一个带有时间戳的
     LogicalEvent。
   * 分析: 这一步的逻辑清晰直接，是后续处理的基础。它正确地将面向对象、可组合的 Morphism
     结构转换成了编译器内部更容易处理的、线性的事件列表。此处的逻辑是稳健的，没有明显问题。

  Pass 1: `_pass1_translate_to_oasm` (逻辑翻译)

   * 逻辑: 这一步是编译的核心，负责将抽象的 LogicalEvent 翻译成具体的 OASMCall（即对 OASM DSL
     函数的调用）。它会遍历事件，根据操作类型（OperationType）生成对应的 OASM 调用。
       * 对于像 TTL_SET 这样的操作，它能智能地将同一时刻发生在多个通道上的操作合并成一个带掩码（mask）的 OASM
         调用，以提高效率。
       * 在处理 SYNC_MASTER（主板同步）事件时，它会调用辅助函数 _calculate_master_wait_time
         来计算主板在触发从板同步前需要等待的时间。我们刚刚修复的 bug 就位于这个环节。
   * 分析:
       * 优点: 合并逻辑（如 TTL）是很好的优化。将抽象操作映射到具体 OASM 函数的逻辑分离清晰。
       * 潜在问题:
           1. 硬编码的同步码: 代码中使用了硬编码的 sync_code = 12345。在当前场景下可行，但如果未来系统需要支持
              多个、独立的全局同步组，这个同步码可能需要动态生成或由用户指定，以避免冲突。
           2. 依赖关系: 这一步的正确性高度依赖于 Pass 0 提供的、按时序排列的事件列表。

  Pass 1.5: `_detect_epoch_boundaries` (Epoch 边界检测)

   * 逻辑: 这是一个较新的 Pass，专门用于处理包含多次 global_sync 的复杂序列。它通过扫描事件流，寻找
     SYNC_MASTER 和 SYNC_SLAVE
     同时出现的时间点。每当找到这样一个完整的同步握手，它就认为一个“纪元”（Epoch）结束了，并为后续的事件增加
     Epoch 编号。
   * 分析:
       * 优点: 这是对编译器一个非常重要的增强。它使得编译器能够区分同步操作前后的时间域，防止了跨同步边界的非
         法时序依赖（例如，将一个操作从一个 Epoch 调度到另一个 Epoch），极大地提升了编译器的健壮性。
       * 分析: 逻辑清晰，正确地将同步点识别为 Epoch 的分界线。

  Pass 2: `_pass2_analyze_costs` (成本分析)

   * 逻辑: 这一步通过调用 oasm 库来分析每个 LogicalEvent 转换成的 OASM
     调用的实际执行成本（时钟周期）。它会为每个事件生成一小段 RTMQ
     汇编代码，然后通过分析汇编指令来估算其执行时间。
   * 分析:
       * 优点: 提供了精确的指令级 timing 信息，这是后续 Pass 3 和 Pass 4 进行时序约束检查和流水线优化的基础。
       * 潜在问题:
           1. 外部库依赖: 强依赖 oasm 库。代码中做了可用性检查，如果库不存在则跳过此 Pass，这是很好的容错处理。
           2. 成本模型的准确性: _estimate_oasm_cost 函数依赖一个名为 RTMQ_INSTRUCTION_COSTS
              的字典来估算成本。这个字典的准确性直接决定了整个时序分析的成败。如果底层硬件或 RTMQ
              指令集的行为发生变化，这个字典必须同步更新，这是一个维护上的关键点。

  Pass 3 & 3.5: `_pass3_check_constraints` & `_check_cross_epoch_violations` (约束检查)

   * 逻辑: 在拥有了精确的成本信息后，这一步负责检查各种时序约束。
       * Pass 3: 检查流水线（Pipelining）约束，确保 RWG 的 PLAY 操作有足够长的时间来“隐藏”下一次 LOAD
         操作的耗时。同时检查多板场景下的 RWG_INIT 是否在第一次同步前（Epoch 0）完成。
       * Pass 3.5: 检查是否存在跨越 Epoch 的非法操作，作为 Pass 1.5 的补充和验证。
   * 分析:
       * 优点: 错误检查非常关键。这里的约束检查逻辑覆盖了几个已知的、容易出错的关键点，能给用户提供清晰的错误
         反馈，而不是生成错误的代码。
       * 分析: 目前的检查点是合理的。未来如果硬件增加新的约束，可以方便地在这里添加新的检查函数。

  Pass 4: `_pass4_generate_oasm_calls` (最终代码生成与调度)

   * 逻辑: 这是最后一步。它负责生成最终的、经过调度的 OASM 调用序列。
       1. 它首先调用 _identify_pipeline_pairs 找出所有可以进行流水线优化的 LOAD -> PLAY 操作对。
       2. 然后调用 _calculate_optimal_schedule 重新安排 LOAD 操作的时间，使其尽可能地被前一个 PLAY
          操作的执行时间所覆盖，从而减少等待。
       3. 最后，它遍历优化后的事件列表，在线性时间轴上插入必要的 WAIT_US 调用，生成最终的 OASM 调用流。
   * 分析:
       * 优点: 流水线调度优化是这个编译器的亮点功能，可以显著提升序列的执行效率。将事件重新排序并插入等待，是
         生成最终代码的正确方法。
       * 潜在问题: 调度算法（_calculate_optimal_schedule）是编译器中最复杂的部分之一。虽然目前的逻辑看起来是合
         理的（总是尝试将 LOAD 推迟到尽可能晚的时刻执行），但在更复杂的场景下（例如，多条并行的、相互依赖的流
         水线），可能会有更优的调度策略。

  总结

  编译器的四步（现在更像是六步）流水线设计是清晰且模块化的，每一层各司其职，逻辑层层递进。从事件提取、翻译、
  成本分析、约束检查到最终的优化和代码生成，整个流程非常完整和健壮。

  总体来看，当前编译器的逻辑没有明显的设计缺陷。 我之前修复的 bug
  是一个实现层面的细节问题，而不是设计思路的错误。编译器的核心架构是稳固的。